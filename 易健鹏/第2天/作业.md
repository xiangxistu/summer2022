## 1信号量

信号量获取，从创建的信号量资源中获取一个信号量，获取成功返回正确。否则线程会等待其它线程释放该信号量，超时时
间由用户设定。当线程获取信号量失败时，线程将进入阻塞态，系统将线程挂到该信号量的阻塞列表中。

### 二值信号量的运作机制

在二值信号量无效的时候，假如此时有线程获取该信号量的话，那么线程将进入阻塞状态

<img src="https://doc.embedfire.com/rtos/rtthread/zh/latest/_images/semaph002.png" title="" alt="avatar" data-align="center">

假如某个时间中断/线程释放了信号量，由于获取无效信号量而进入阻塞态的线程
将获得信号量并且恢复为就绪态。

<img title="" src="https://doc.embedfire.com/rtos/rtthread/zh/latest/_images/semaph004.png" alt="avatar" data-align="center">

### 计数型信号量的运作机制

计数型信号量与二值信号量其实都是差不多的，一样用于资源保护，不过计数信号量则允许多个线程获取信号量访问共享资源，但会限制线程的最大数目。访问的线程数达到信号量可支持的最大数目时，会阻塞其他试图获取该信号量的线程，直到有线程释放了信号量。

![avatar](https://doc.embedfire.com/rtos/rtthread/zh/latest/_images/semaph005.png)

## 2互斥量

用互斥量处理不同线程对临界资源的同步访问时，线程想要获得互斥量才能进行资源访问，如果一旦有线程成功获得了互斥量，则互斥量立即变为闭锁状态，此时其他线程会因为获取不到互斥量而不能访问这个资源，线程会根据用户自定义的等待时间进行等待，直到互斥量被持有的线程释放后，其他线程才能获取互斥量从而得以访问该临界资源，此时斥量再次上锁，如此一来就可以确保每个时刻只有一个线程正在访问这个临界资源，保证了临界资源操作的安全性。

![avatar](https://doc.embedfire.com/rtos/rtthread/zh/latest/_images/mutex004.png)

## 3 事件



![avatar](https://doc.embedfire.com/rtos/rtthread/zh/latest/_images/event002.png)

事件唤醒机制，当线程因为等待某个或者多个事件发生而进入阻塞态，当事件发生的时候会被唤醒，其过程具体见 下图。

![avatar](https://doc.embedfire.com/rtos/rtthread/zh/latest/_images/event003.png)

线程1对事件3或事件5感兴趣（逻辑或RT_EVENT_FLAG_OR），当发生其中的某一个事件都会被唤醒，并且执行相应操作。而线程2对事件3与事件5感兴趣（逻辑与RT_EVENT_FLAG_AND），当且仅当事件3与事件5都发生的时候，线程2才会被唤
醒，如果只有一个其中一个事件发生，那么线程还是会继续等待事件发生。如果接在收事件函数中option设置了清除事件位，那么当线程唤醒后将把事件3和事件5的事件标志清零，否则事件标志将依然存在。

#### 4邮箱

  RT-Thread操作系统的邮箱对象由多个元素组成，当邮箱被创建时，它就被分配了邮箱控制 块：邮箱名称、邮箱缓冲区起始地址、邮箱大小等。同时每个邮箱对象中包含着多个邮件框，每个邮件框可以存放一封邮件；所有邮箱中的邮件框总数即是邮箱的大小，这个大小可在邮箱创建时指定。

线程或者中断服务程序都可以给邮箱发送邮件，非阻塞方式的邮件发送过程能够安全的应用于中断服务中，中断服务函数、定时器向线程发送消息的有效手段，而阻塞方式的邮件发送只能应用于线程中。当发送邮件时，当且仅当邮箱还没满邮件的时候才能进行发送，如果邮箱已满，可以根据用户设定的等待时间进行等待，当邮箱中的邮件被收取而空出空间来时，等待挂起的发送线程将被唤醒继续发送的过程，当等待时间到了还未完成
发送邮件，或者未设置等待时间，此时发送邮件失败，发送邮件的线程或者中断程序会收到一个错误码（-RT_EFULL）。线程发送邮件可以带阻塞，但在中断中不能采用任何带阻塞的方式发送邮件。

接收邮件时，根据邮箱控制块中的entry判断队列是否有邮件，如果邮箱的邮件非空，那么可以根据out_offset找到最先发送到邮箱中的邮件进行接收。在接收时如果邮箱为空，如果用户设置了等待超时时间，系统会将当前线程挂起，当达到设置的超时时间，邮箱依然未收到邮件时，那么线程将被唤醒并返回-RT_ETIMEOUT。如果邮箱中存在邮件，那么接收线程将复制邮箱中的4个字节邮件到接收线程中。通常来说，邮件收取过程可能是阻塞的，这取决于邮箱中是否有邮件，以及收取邮件时设置的超时时间。

当消邮箱不再被使用时，应该删除它以释放系统资源，一旦操作完成，邮箱将被永久性的删除。

![avatar](https://doc.embedfire.com/rtos/rtthread/zh/latest/_images/mailbo002.png)

## 5消息队列

创建消息队列时先创建一个消息队列对象控制块，然后给消息队列分配一块内存空间，组织成空闲消息链表，这块内存的大小等于[消息大小+消息头（用于链表连接）]与消息队列容量的乘积，接着再初始化消息队列，此时消息队列为空。

RT-Thread操作系统的消息队列对象由多个元素组成，当消息队列被创建时，它就被分配了消息队列控制块：消息队列名称、内存缓冲区、消息大小以及队列长度等。同时每个消息队列对象中包含着多个消息框，每个消息框可以存放一条消息；消息队列中的第一个和最后一个消息框被分别称为消息链表头和消息链表尾，对应于消息
队列控制块中的msg_queue_head和msg_queue_tail；有些消息框可能是空的，它们通过msg_queue_free形成一个空闲消息框链表。所有消息队列中的消息框总数即是消息队列的长度，这个长度可在消息队列创建时指定。

线程或者中断服务程序都可以给消息队列发送消息。当发送消息时，消息队列对象先从空闲消息链表上取下一个空闲消息块，把线程或者中断服务程序发送的消息内容复制到消息块上，然后把该消息块挂到消息队列的尾部。当且仅当空闲消息链表上有可用的空闲消息块时，发送者才能成功发送消息；当空闲消息链表上无可用消息块，说明消
息队列已满，此时，发送消息的的线程或者中断程序会收到一个错误码（-RT_EFULL）。

发送紧急消息的过程与发送消息几乎一样，唯一的不同是，当发送紧急消息时，从空闲消息链表上取下来的消息块不是挂到消息队列的队尾，而是挂到队首，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。

读取消息时，根据msg_queue_head找到最先入队列中的消息节点进行读取。根据消息队列控制块中的entry判断队列是否有消息读取，对全部空闲（entry为0）队列进行读消息操作会引起线程挂起。

当消息队列不再被使用时，应该删除它以释放系统资源，一旦操作完成，消息队列将被永久性的删除。

![avatar](https://doc.embedfire.com/rtos/rtthread/zh/latest/_images/messag002.png)
