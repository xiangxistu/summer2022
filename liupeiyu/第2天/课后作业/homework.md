IPC 能够唤醒，挂起线程的原因：

1. 信号量：通过rt_sem_take(rt_sem_t sem, rt_int32_t timeout)函数使得线程在没有接收到信号量时处于等待状态，即挂起。当接收到信号量时唤醒。信号量则可以由任何线程释放

2. 互斥量：通过rt_mutex_take(rt_mutex_t mutex, rt_int32_t timeout)函数使得线程在没有接收到信号量时处于等待状态，即挂起。当接收到信号量时唤醒。互斥量只能由持有线程释放

3. 事件：通过rt_event_recv(rt_event_t   event,  
                          rt_uint32_t  set,
                          rt_uint8_t   option,
                          rt_int32_t   timeout,
                          rt_uint32_t *recved)

   函数控制线程的挂起和唤醒。

4. 邮箱：通过一个进程发送数据，另一个进程读取数据，根据数据判断执行什么操作

5. 消息队列：消息队列能够接收来自线程或中断服务例程中不固定长度的消息，并把消息缓存在自己的内存空间中。其他线程也能够从消息队列中读取相应的消息，而当消息队列是空的时候，可以挂起读取线程。当有新的消息到达时，挂起的线程将被唤醒以接收并处理消息。消息队列是一种异步的通信方式。